/**
 * @file CppTranspiler.cpp
 * @author Conlan Wesson
 * @copyright (c) 2025, Conlan Wesson, GNU General Public License v3
 */

#include "CppTranspiler.h"
#include "sym/SymbolTable.h"
#include "PrimitiveType.h"
#include "UserType.h"
#include "TypeDecorator.h"
#include <functional>
#include <sstream>

CppTranspiler::CppTranspiler(std::ostream& o) :
	os(o),
	indent(),
	in_params(false),
	is_last(false),
	is_member(false),
	array_depth(0),
	ptr_count(0),
	insert_last(nullptr)
{
	os << "/**************************************************" << std::endl;
	os << " * DO NOT EDIT THIS FILE." << std::endl;
	os << " * This file was generated by the Sprokit compiler." << std::endl;
	os << " *************************************************/" << std::endl;
	os << std::endl;
	os << "// Sprokit preamble" << std::endl;
	os << "#include <cmath>" << std::endl;
	os << "#include <cstdint>" << std::endl;
	os << "typedef int8_t int8;" << std::endl;
	os << "typedef int16_t int16;" << std::endl;
	os << "typedef int32_t int32;" << std::endl;
	os << "typedef int64_t int64;" << std::endl;
	os << "typedef __fp16 float16;" << std::endl;
	os << "typedef float float32;" << std::endl;
	os << "typedef double float64;" << std::endl;
	os << "// End Sprokit preamble" << std::endl;
	os << std::endl;
}
std::string CppTranspiler::translateType(const ADT::BoolType& t) const {
	return "bool";
}

std::string CppTranspiler::translateType(const ADT::IntType& t) const {
	std::stringstream s;
	s << "int" << t.length;
	return s.str();
}

std::string CppTranspiler::translateType(const ADT::FloatType& t) const {
	std::stringstream s;
	s << "float" << t.size()*8;
	return s.str();
}

std::string CppTranspiler::translateType(const ADT::UserType& t) const {
	return (std::string)t;
}

std::string CppTranspiler::translateType(const ADT::PointerType& t) const {
	++ptr_count;
	std::stringstream s;
	s << (std::string)t.type.translate(*this) << "*";
	return s.str();
}

std::ostream& operator<<(std::ostream& o, CppTranspiler::Indent indent) {
	for(unsigned int i = 0; i < indent.value; ++i){
		o << "    ";
	}
	return o;
}

std::string CppTranspiler::formatUnit(std::string u) {
	if(u == "" || u == "#1"){
		return "";
	}else{
		return std::string(" /*") + u + std::string("*/");
	}
}

std::ostream& CppTranspiler::arrlen(std::ostream& os) {
	os << "__sprokit_arrlen_" << array_depth << "_";
	return os;
}

void CppTranspiler::visit(AST::Addition& v) {
	os << "(";
	v.left->accept(*this);
	os << " + ";
	v.right->accept(*this);
	os << ")";
}

void CppTranspiler::visit(AST::Array& v) {
	os << "[";
	if(v.expression != nullptr){
		v.expression->accept(*this);
	}else if(in_params){
		os << "*";
	}
	os << "]";
	if(v.array != nullptr){
		++array_depth;
		v.array->accept(*this);
	}
}

void CppTranspiler::visit(AST::Assignment& v) {
	os << indent;
	v.var->accept(*this);
	os << " = ";
	v.expression->accept(*this);
	os << ";" << std::endl;
}

void CppTranspiler::visit(AST::BoolLiteral& v) {
	os << (v.value ? "true" : "false");
}

void CppTranspiler::visit(AST::Conversion& v) {
	os << indent << "// " << v.to << " = ";
	v.expression->accept(*this);
	os << std::endl;
}

void CppTranspiler::visit(AST::Division& v) {
	os << "(";
	v.left->accept(*this);
	os << " / ";
	v.right->accept(*this);
	os << ")";
}

void CppTranspiler::visit(AST::Equal& v) {
	v.left->accept(*this);
	os << " == ";
	v.right->accept(*this);
}

void CppTranspiler::visit(AST::Exponent& v) {
	os << "std::pow(";
	v.left->accept(*this);
	os << ", ";
	v.right->accept(*this);
	os << ")";
}

void CppTranspiler::visit(AST::FloatLiteral& v) {
	os << v.value << formatUnit(v.unit);
}

void CppTranspiler::visit(AST::FunctionCall& v) {
	os << v.name << "(";
	in_params = true;
		v.params->accept(*this);
	in_params = false;
	os << ")";
}

void CppTranspiler::visit(AST::FunctionDeclaration& v) {
	os << std::endl;
	os << indent << v.type << " " << v.name << "(";
	in_params = true;
		v.params->accept(*this);
	in_params = false;
	os << "){" << std::endl;

	++indent;
		v.body->accept(*this);
	--indent;

	os << indent << "}" << std::endl;
}

void CppTranspiler::visit(AST::IfStatement& v) {
	os << indent << "if(";
	v.condition->accept(*this);
	os << "){" << std::endl;

	++indent;
		v.body->accept(*this);
	--indent;

	os << indent << "}";
	if(v.elsebody != nullptr){
		os << " else {" << std::endl;
		++indent;
			v.elsebody->accept(*this);
		--indent;
		os << indent << "}";
	}
	os << std::endl;
}

void CppTranspiler::visit(AST::IntegerLiteral& v) {
	os << v.value << formatUnit(v.unit);
}

void CppTranspiler::visit(AST::List& v) {
	if(v.node != nullptr){
		is_last = (v.next == nullptr);
		v.node->accept(*this);
	}
	if(v.next != nullptr){
		if(in_params && !is_last){
			os << ", ";
		}
		v.next->accept(*this);
	}
}

void CppTranspiler::visit(AST::Member& v) {
	is_member = true;
	is_last = false;
	v.left->accept(*this);
	auto sym = v.table->findVariable(v.left->name);
	if(sym != nullptr){
		ptr_count = 0;
		sym->type->translate(*this);
		if(ptr_count > 0){
			os << "->";
		}else{
			os << ".";
		}
	}else{
		os << ".";
	}
	if(v.isLast()){
		is_last = true;
	}
	v.right->accept(*this);

	is_member = false;
	is_last = true;
}

void CppTranspiler::visit(AST::Modulo& v) {
	os << "(";
	v.left->accept(*this);
	os << " % ";
	v.right->accept(*this);
	os << ")";
}

void CppTranspiler::visit(AST::Multiplication& v) {
	os << "(";
	v.left->accept(*this);
	os << " * ";
	v.right->accept(*this);
	os << ")";
}

void CppTranspiler::visit(AST::NotEqual& v) {
	v.left->accept(*this);
	os << " != ";
	v.right->accept(*this);
}

void CppTranspiler::visit(AST::Pointer& v) {
	os << "&";
	v.var->accept(*this);
}

void CppTranspiler::visit(AST::Property& v) {
	if(v.name == "size"){
		os << "sizeof(";
		v.var->accept(*this);
		os << ")";
	}else if(v.name == "length"){
		if(v.var->array != nullptr && v.var->array->length_var != nullptr){
			os << v.var->array->length_var->name;
		}else{
			insert_last = std::bind(&CppTranspiler::arrlen, this, std::placeholders::_1);
			v.var->accept(*this);
			insert_last = nullptr;
		}
	}else if(v.name == "max"){
	}else if(v.name == "min"){
	}else if(v.name == "align"){
		os << "alignof(";
		v.var->accept(*this);
		os << ")";
	}
}

void CppTranspiler::visit(AST::Return& v) {
	os << indent << "return";
	if(v.expression != nullptr){
		os << " ";
		v.expression->accept(*this);
	}
	os << ";" << std::endl;
}

void CppTranspiler::visit(AST::Subtraction& v) {
	os << "(";
	v.left->accept(*this);
	os << " - ";
	v.right->accept(*this);
	os << ")";
}

void CppTranspiler::visit(AST::TypeDeclaration& v) {
	os << std::endl;
	os << indent << "// type " << v.name << std::endl;
	os << indent << "class " << v.name << " {" << std::endl;

	++indent;
		os << indent << "public:" << std::endl;
		v.list->accept(*this);
	--indent;

	os << indent << "};" << std::endl;
}

void CppTranspiler::visit(AST::UnitDeclaration& v) {
	os << std::endl;
	os << "// unit " << v.unit << std::endl;
	v.list->accept(*this);
	os << std::endl;
}

void CppTranspiler::visit(AST::Variable& v) {
	auto sym = v.table->findVariable(v.name);
	if(sym != nullptr){
		ptr_count = 0;
		sym->type->translate(*this);
		if(ptr_count > 0 && !is_member && insert_last == nullptr){
			os << "*";
		}
	}
	if((is_last || !is_member) && insert_last != nullptr){
		insert_last(os);
	}
	os << v.name;
	if(v.array != nullptr){
		v.array->accept(*this);
	}
}

void CppTranspiler::visit(AST::VariableDeclaration& v) {
	array_depth = 0;
	if(!in_params){
		os << indent;
	}

	if(v.array != nullptr){
		for(AST::Array* a = v.array; a != nullptr; a = a->array){
			if(a->length_var != nullptr){
				a->length_var->accept(*this);
				if(in_params){
					os << ", ";
				}
			}else{
				os << "const unsigned int __sprokit_arrlen_" << array_depth << "_" << v.name;
				if(in_params && a->expression == nullptr){
					os << ", ";
				}else{
					os << " = ";
					a->expression->accept(*this);
					os << ";" << std::endl << indent;
				}
			}
		}
	}

	if(v.constant){
		os << "const ";
	}
	os << v.type.translate(*this);
	os << " " << v.name << formatUnit(v.unit);
	if(v.array != nullptr){
		v.array->accept(*this);
	}
	if(!in_params){
		if(v.initial != nullptr){
			os << " = ";
			v.initial->accept(*this);
		}
		os << ";" << std::endl;
	}
}
